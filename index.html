<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLONK 協定技術報告</title>
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Mermaid JS -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            mermaid.initialize({ 
                startOnLoad: true,
                theme: 'neutral',
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
                securityLevel: 'loose',
                flowchart: { curve: 'basis', htmlLabels: true }
            });
        });
    </script>
    
    <style>
        :root {
            --sidebar-width: 280px;
            --primary-color: #2c3e50;
            --link-color: #3498db;
            --bg-color: #ffffff;
            --text-color: #333333;
            --code-bg: #f8f9fa;
            --border-color: #e9ecef;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans TC", sans-serif;
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Styling */
        .sidebar {
            width: var(--sidebar-width);
            background-color: #f7f9fa;
            border-right: 1px solid var(--border-color);
            padding: 2rem 1rem;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .sidebar h1 {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: var(--primary-color);
            padding-left: 0.5rem;
        }

        .sidebar nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar nav li {
            margin-bottom: 0.5rem;
        }

        .sidebar nav a {
            text-decoration: none;
            color: #57606a;
            font-size: 0.95rem;
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .sidebar nav a:hover, .sidebar nav a.active {
            background-color: #e1e4e8;
            color: var(--primary-color);
            font-weight: 500;
        }

        /* Main Content Styling */
        main {
            flex-grow: 1;
            padding: 2rem 4rem;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        section {
            max-width: 900px;
            margin: 0 auto 4rem auto;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 2rem;
        }

        section:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: 2rem;
            color: var(--primary-color);
            margin-top: 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.5rem;
            color: #4a5568;
            margin-top: 2rem;
        }

        h4 {
            font-size: 1.2rem;
            color: #4a5568;
            margin-top: 1.5rem;
        }

        p {
            line-height: 1.7;
            margin-bottom: 1.2rem;
            text-align: justify;
        }

        ul, ol {
            line-height: 1.7;
            margin-bottom: 1.2rem;
            padding-left: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        strong {
            color: #2c3e50;
            font-weight: 700;
        }

        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            color: #d63384;
        }

        .math {
            font-size: 1.05em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: var(--code-bg);
            font-weight: 600;
        }
        
        /* Author Info */
        .author-info {
            margin-top: -1.5rem;
            margin-bottom: 2rem;
            font-size: 1.1rem;
            color: #555;
            font-weight: 500;
        }

        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--link-color);
            text-decoration: none;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: var(--link-color);
            color: white;
            border-color: var(--link-color);
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
                overflow: auto;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                height: auto;
            }
            main {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>

<aside class="sidebar">
    <h1>PLONK 技術報告</h1>
    <nav>
        <ul>
            <li><a href="#abstract">0. 摘要 (Abstract)</a></li>
            <li><a href="#intro">1. 前言與動機 (Introduction)</a></li>
            <li><a href="#system-roles">2. 系統與角色模型 (System Roles)</a></li>
            <li><a href="#overview">3. 整體流程概觀 (Overview)</a></li>
            <li><a href="#math">4. 數學與建模基礎 (Math Foundation)</a></li>
            <li><a href="#permutation">5. Permutation Argument</a></li>
            <li><a href="#setup">6. 通用初始設定 (Setup)</a></li>
            <li><a href="#preprocessing">7. 電路預處理 (Preprocessing)</a></li>
            <li><a href="#proving">8. Prover 流程 (Proving)</a></li>
            <li><a href="#verification">9. Verifier 流程 (Verification)</a></li>
            <li><a href="#performance">10. 效能與實作 (Performance)</a></li>
            <li><a href="#security">11. 安全性與擴充 (Security)</a></li>
            <li><a href="#conclusion">12. 結論 (Conclusion)</a></li>
        </ul>
    </nav>
</aside>

<main>

    <section id="abstract">
        <h2>0. 摘要 (Abstract)</h2>
        <div class="author-info">報告人：高璿程</div>
        <p>
            零知識簡潔非互動式知識論證（zk-SNARK）在區塊鏈隱私與擴展性應用中扮演關鍵角色。本報告分析的 PLONK 協定旨在解決現有方案的效能瓶頸，其核心要點如下：
        </p>
        <ul>
            <li><strong>問題背景</strong>：早期的 Groth16 依賴針對特定電路的 trusted setup，限制了部署靈活性；而 Sonic 雖然引入了通用參考字串（Universal SRS），但其證明者（Prover）計算成本過高，難以滿足實際需求。</li>
            <li><strong>PLONK 的核心貢獻</strong>：
                <ul>
                    <li>採用基於<strong>拉格朗日基底 (Lagrange bases)</strong> 與<strong>乘法子群</strong>的算術化方案。</li>
                    <li>引入新穎的<strong>置換論證 (Permutation Argument)</strong> 來簡化電路中線路連接 (wiring) 的檢查。</li>
                    <li>相較於 Sonic，顯著降低了 Prover 的群指數運算次數，將證明生成速度提升了數倍至一個數量級。</li>
                </ul>
            </li>
            <li><strong>報告主軸</strong>：本報告將從「系統角色」與「技術流程」的角度解構 PLONK，詳細探討多項式承諾方案、Permutation Check 機制、Prover 的五輪互動，以及 Verifier 如何透過常數次配對運算完成高效驗證。</li>
        </ul>
    </section>

    <section id="intro">
        <h2>1. 前言與動機 (Introduction)</h2>
        
        <h3>1.1 背景：zk-SNARK 與通用 SRS</h3>
        <p>
            zk-SNARK 技術允許證明者向驗證者證明計算正確性而不洩露私密輸入。一個理想的「完全簡潔 (fully succinct)」SNARK 應滿足以下四個條件：
        </p>
        <ol>
            <li><strong>SRS 生成時間短且安全</strong>。</li>
            <li><strong>Prover 計算效率高</strong>（運算量與電路大小呈線性或準線性關係）。</li>
            <li><strong>Proof 長度極短</strong>（如常數大小或對數級）。</li>
            <li><strong>Verifier 驗證時間極短</strong>（常數時間或對數時間）。</li>
        </ol>
        <p>
            早期的 Groth16 方案雖在驗證速度與證明大小上表現優異，但其 <strong>SRS 綁定特定電路</strong>，一旦電路邏輯修改，就需要重新進行多方計算儀式（MPC setup），這極大限制了靈活性。
        </p>

        <h3>1.2 Sonic 的限制與 PLONK 的目標</h3>
        <p>
            Sonic 協定是首個實現「<strong>通用且可更新 SRS</strong>」的實用 zk-SNARK，這意味著同一個 SRS 可以支援所有不超過特定大小的電路。然而，Sonic 在追求通用性的同時付出了代價：其 Prover 需要進行大量的昂貴群運算。<strong>PLONK 的設計目標</strong>正是在保留 Sonic 通用性優勢的同時，大幅優化 Prover 的計算複雜度，並減少 SRS 的大小，使其效能更接近 Groth16。
        </p>

        <h3>1.3 本報告的架構</h3>
        <p>
            本報告將按以下結構深入剖析 PLONK：
        </p>
        <ul>
            <li><strong>第 2 章</strong>：定義系統中的參與角色、信任模型與對手模型。</li>
            <li><strong>第 3–7 章</strong>：技術核心，介紹運作流程、數學基礎、Permutation Argument、Setup 與 Preprocessing。</li>
            <li><strong>第 8–9 章</strong>：詳細拆解 Prover 的證明生成步驟與 Verifier 的驗證邏輯。</li>
            <li><strong>第 10–12 章</strong>：分析效能、安全性論證與結論。</li>
        </ul>
    </section>

    <section id="system-roles">
        <h2>2. 系統與角色模型 (System Roles)</h2>

        <h3>2.1 系統概觀與信任模型</h3>
        <p>
            PLONK 建立在<strong>通用參考字串 (Universal Structured Reference String, SRS)</strong> 模型之上。與傳統電路專用 SRS 不同，通用的 SRS 透過多方計算（MPC）儀式生成，具有「<strong>可更新 (updatable)</strong>」特性。只要儀式中至少有一位參與者是誠實的，生成的 SRS 就是安全的。
        </p>

        <h3>2.2 主要角色</h3>
        <p>在理解 PLONK 時，我們區分「現實世界中的參與者」與「安全證明模型中的角色」：</p>
        
        <h4>現實世界參與者</h4>
        <ul>
            <li><strong>Setup 參與者</strong>：負責執行 MPC 儀式，生成 monomials SRS <span class="math">\(\{ [x^i]_1, [x^i]_2 \}\)</span>。</li>
            <li><strong>電路設計者</strong>：定義約束系統 <span class="math">\(\mathcal{C}\)</span>，產生預處理參數（選擇子與置換承諾），即 Verification Key。</li>
            <li><strong>證明者 (Prover)</strong>：持有 witness，計算證明 <span class="math">\(\pi\)</span>。</li>
            <li><strong>驗證者 (Verifier)</strong>：驗證證明 <span class="math">\(\pi\)</span>。</li>
        </ul>

        <h4>抽象模型角色 (Polynomial IOP)</h4>
        <ul>
            <li><strong>理想第三方 (Ideal Trusted Party, $\mathcal{I}$)</strong>：在抽象協議中，Prover 將多項式完整地傳送給 $\mathcal{I}$。$\mathcal{I}$ 誠實地回答 Verifier 對這些多項式在特定點的詢問。這簡化了對多項式行為的分析。</li>
            <li><strong>代數對手 (Algebraic Adversary, $\mathcal{A}$)</strong>：這是我們假設的攻擊者模型。</li>
        </ul>

        <h3>2.3 對手模型與 AGM 安全性</h3>
        <p>
            PLONK 的安全性分析基於<strong>代數群模型 (Algebraic Group Model, AGM)</strong>。在此模型中，每當對手輸出一個群元素 <span class="math">\(Y\)</span>，他必須同時提供該元素如何由輸入元素線性組合而成的係數。
        </p>
        <p>
            <strong>Lemma 2.2 的直覺</strong>：AGM 允許我們將複雜的雙線性配對檢查 (Real Pairing Check) 還原為多項式恆等式檢查 (Ideal Polynomial Check)。具體來說，如果一個代數對手能欺騙 Pairing Check，則相當於他在不知情的情況下解決了離散對數問題 (Q-DLOG)。這確保了只要 Polynomial Protocol 是安全的（具有 <strong>Knowledge Soundness</strong>），編譯後的 SNARK 就是安全的。
        </p>
    </section>

    <section id="overview">
        <h2>3. 整體流程概觀 (Overview)</h2>

        <h3>3.1 協定生命週期</h3>
        <p>PLONK 的運作可以分為四個主要階段：</p>
        
        <!-- Mermaid Diagram Insertion -->
        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            %% 定義樣式
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef artifact fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;
            classDef actor fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;

            %% 1. Setup Phase
            subgraph Phase1 ["Phase 1 通用 Setup (MPC)"]
                SetupAction("執行 MPC 儀式"):::process
                SRS("通用 SRS"):::artifact
                SetupAction --> SRS
            end

            %% 2. Preprocessing Phase
            subgraph Phase2 ["Phase 2 電路預處理"]
                Circuit("電路邏輯 C"):::artifact
                Compile("編譯與承諾"):::process
                VK("Verification Key"):::artifact
                Circuit --> Compile
                SRS -.-> Compile
                Compile --> VK
            end

            %% 3. Proving Phase
            subgraph Phase3 ["Phase 3 證明生成"]
                InputData("Witness + Public Input"):::artifact
                
                subgraph Rounds ["互動回合 Round 1-5"]
                    direction TB
                    R1("Round 1 Wire Polys"):::process
                    R2("Round 2 Permutation Poly"):::process
                    R3("Round 3 Quotient Poly"):::process
                    R4("Round 4 Evaluations"):::process
                    R5("Round 5 Opening Proofs"):::process
                    
                    R1 --> R2 --> R3 --> R4 --> R5
                end
                
                Proof("Proof"):::artifact
                
                SRS -.-> R1
                InputData --> R1
                R5 --> Proof
            end

            %% 4. Verification Phase
            subgraph Phase4 ["Phase 4 驗證"]
                VerifyCheck{"Pairing Check"}:::process
                Result(["Accept or Reject"])
                
                SRS -.-> VerifyCheck
                VK --> VerifyCheck
                Proof --> VerifyCheck
                PI("Public Input"):::artifact --> VerifyCheck
                VerifyCheck --> Result
            end

            %% Global Data Flow Connections
            SRS -.-> Compile
            SRS -.-> VerifyCheck
            
            linkStyle default stroke:#333,stroke-width:1px;
        </div>

        <ol>
            <li><strong>通用 Setup (Universal Setup)</strong>：執行一次性的 MPC 儀式，產出全域通用的 SRS。</li>
            <li><strong>電路預處理 (Preprocessing)</strong>：針對特定電路進行編譯，產生 Selector 與 Permutation 多項式的承諾（Verification Key）。</li>
            <li><strong>證明生成 (Proving)</strong>：Prover 根據私密輸入 (Witness) 與公開輸入，執行 5 輪互動協議，生成證明 <span class="math">\(\pi\)</span>。</li>
            <li><strong>驗證 (Verification)</strong>：Verifier 執行 Batched Pairing 檢查，確認所有多項式約束成立。</li>
        </ol>

        <h3>3.2 資料流與訊息流</h3>
        <p>
            整個協定的資料流向如下：
            <br>
            <strong>SRS</strong> $\rightarrow$ (Setup) $\rightarrow$ <strong>Prover & Verifier</strong><br>
            <strong>Circuit Logic</strong> $\rightarrow$ (Preprocessing) $\rightarrow$ <strong>Verification Key</strong> $\rightarrow$ <strong>Verifier</strong><br>
            <strong>Witness + Public Input</strong> $\rightarrow$ (Prover Computation) $\rightarrow$ <strong>Proof $\pi$</strong> $\rightarrow$ <strong>Verifier</strong><br>
        </p>

        <h3>3.3 角色與步驟對照表</h3>
        <ul>
            <li><strong>Setup</strong>：產生 SRS <span class="math">\(\mathsf{srs}\)</span>。</li>
            <li><strong>Designer</strong>：輸出 <span class="math">\([q_L]_1, [q_R]_1, \dots, [S_{\sigma 1}]_1, [S_{\sigma 2}]_1, [S_{\sigma 3}]_1\)</span>。</li>
            <li><strong>Prover</strong>：
                <ul>
                    <li>Round 1: Commit wires $a, b, c$。</li>
                    <li>Round 2: Commit permutation accumulator $z$。</li>
                    <li>Round 3: Commit quotient parts $t_{lo}, t_{mid}, t_{hi}$。</li>
                    <li>Round 4: Send evaluations $\bar{a}, \bar{b}, \bar{c}, \dots$。</li>
                    <li>Round 5: Send linearization proof $W_z, W_{z\omega}$。</li>
                </ul>
            </li>
            <li><strong>Verifier</strong>：重建挑戰值，執行配對驗證。</li>
        </ul>

        <h3>3.4 通用 SRS 與更換電路的實際流程</h3>
        <p>
            PLONK 的「通用 SRS」並不是什麼都不用管，而是：同一份 SRS 可以支援所有「多項式次數不超過某個上限」的電路。換電路時，只需要重新做「電路預處理」，不需要重新跑一次昂貴的 MPC setup。
            可以把整個過程拆成兩個層次：
        </p>
        <p><strong>（1）一次性的 Universal Setup（只做一次）</strong></p>
        <ul>
            <li>在多方儀式中選出一個隨機秘密值 $x \in \mathbb{F}$，建立 monomial SRS：
            $[1]_1, [x]_1, \dots, [x^{d-1}]_1, [1]_2, [x]_2$。</li>
            <li>這裡的 $d$ 對應「最大支援 degree」，也就是你想支援的最大電路大小。之後所有電路裡出現的多項式（wire、多項式約束、permutation 等）都必須是 degree < $d$ 才能用這份 SRS 承諾。</li>
        </ul>
        <p><strong>（2）針對每一個電路 $\mathcal{C}$ 的預處理（可以想成「編譯電路」）</strong></p>
        <ul>
            <li>對於每一個具體電路 $\mathcal{C}$：
                <ul>
                    <li>先把電路轉成 PLONK 的 constraint system，產生對應的 selector 多項式 $q_L, q_R, q_O, q_M, q_C$，以及 permutation 多項式 $S_{\sigma 1}, S_{\sigma 2}, S_{\sigma 3}$。</li>
                    <li>確認這些多項式的 degree 都小於當初 setup 設的上限 $d$。</li>
                    <li>用同一份 SRS 計算它們的 KZG 承諾，得到：
                    $[q_L]_1, [q_R]_1, [q_O]_1, [q_M]_1, [q_C]_1, [S_{\sigma 1}]_1, [S_{\sigma 2}]_1, [S_{\sigma 3}]_1$。</li>
                    <li>把這些承諾加上一些電路尺寸、根 $\omega$、coset 因子 $k_1, k_2$ 等共同參數，打包成「這個電路專用的 Verification Key (VK)」。</li>
                </ul>
            </li>
        </ul>
        <p>
            這樣，換一個電路時，實際上發生的只有：
            <ol>
                <li>設計新的算術電路 $\mathcal{C}'$（gate 數不要超過當初 SRS 的上限）。</li>
                <li>重新生成新的 selector/permutation 多項式。</li>
                <li>用同一份 $\mathsf{srs}$ 算出新的承諾，得到新的 $\text{VK}_{\mathcal{C}'}$。</li>
                <li>Prover 在產生證明時，使用「舊的 SRS ＋ 新電路的 VK」來跑 PLONK 的 5 個 round。</li>
                <li>Verifier 在驗證時，只要選對「這個 statement 對應的 VK」，但 SRS 不用換。</li>
            </ol>
            因此，一個系統只要做一次通用的 MPC setup（生成 SRS），之後可以不斷「上新電路」，每個電路只需要多一份 VK，不用每次重來一次 setup 儀式。這就是「universal SRS」在實務上的意義。
        </p>
    </section>

    <section id="math">
        <h2>4. 數學與建模基礎 (Math Foundation)</h2>

        <h3>4.1 有限域、群與配對</h3>
        <p>
            PLONK 運作在有限域 <span class="math">\(\mathbb{F}\)</span> 上。使用雙線性配對群 <span class="math">\(e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T\)</span>，其中 <span class="math">\(\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T\)</span> 為階數為質數 <span class="math">\(p\)</span> 的群。配對函數 <span class="math">\(e\)</span> 具有雙線性性質，是驗證多項式乘法關係的基礎。
        </p>

        <h3>4.2 乘法子群與 Lagrange 基底</h3>
        <p>
            為了高效進行快速傅立葉變換 (FFT)，PLONK 選擇一個階數為 <span class="math">\(n\)</span> 的乘法子群 <span class="math">\(H = \{1, \omega, \dots, \omega^{n-1}\} \subset \mathbb{F}^*\)</span>。
            這允許我們使用 <strong>Lagrange 基底</strong> <span class="math">\(\{L_i(X)\}_{i=1}^n\)</span> 來表示多項式，其中 <span class="math">\(L_i(\omega^{j}) = \delta_{ij}\)</span>。
            這種表示法使得在 <span class="math">\(H\)</span> 上定義的約束非常稀疏且易於計算。零多項式定義為 <span class="math">\(Z_H(X) = X^n - 1\)</span>，它在 <span class="math">\(H\)</span> 中所有點上皆為零。
        </p>

        <h3>4.3 多項式承諾 (KZG PCS)</h3>
        <p>
            PLONK 使用 <strong>Kate-Zaverucha-Goldberg (KZG)</strong> 多項式承諾方案。
        </p>
        <ul>
            <li><strong>Commit</strong>: Prover 計算 <span class="math">\([f]_1 = f(x) \cdot G_1\)</span>。</li>
            <li><strong>Open</strong>: Prover 證明 <span class="math">\(f(z) = y\)</span>，產生證明 <span class="math">\(\pi = \frac{f(X)-y}{X-z}\)</span> 的承諾。</li>
            <li><strong>Verify</strong>: Verifier 透過配對檢查承諾的正確性。</li>
        </ul>
        <p>KZG 支援批次開啟 (batched opening)，這對減少 PLONK proof 大小至關重要。</p>

        <h3>4.4 Polynomial Protocol 與 Ranged Protocol</h3>
        <p>
            <strong>Polynomial Protocol</strong> 是一個抽象模型，Verifier 查詢 Prover 多項式在隨機點的評估值，並檢查多項式恆等式。
            <strong>Ranged Protocol</strong> 則處理如「對於所有 <span class="math">\(x \in H\)</span>，<span class="math">\(P(x)=0\)</span>」這類約束。這在代數上等價於證明 <span class="math">\(P(X)\)</span> 能被 <span class="math">\(Z_H(X)\)</span> 整除。
        </p>
    </section>

    <section id="permutation">
        <h2>5. Permutation Argument</h2>

        <h3>5.1 單一多項式的 Permutation Check</h3>
        <p>
            PLONK 的核心創新在於其置換論證。基於 Bayer-Groth 的想法，若要證明兩個序列 <span class="math">\((a_1, \dots, a_n)\)</span> 與 <span class="math">\((b_1, \dots, b_n)\)</span> 是彼此的置換（即包含相同的元素集合），我們可以引入隨機數 <span class="math">\(\beta, \gamma\)</span>，並證明多項式乘積相等：
            <span class="math">\[ \prod_{i=1}^n (a_i + \beta \cdot i + \gamma) = \prod_{i=1}^n (b_i + \beta \cdot \sigma(i) + \gamma) \]</span>
        </p>

        <h3>5.2 Grand Product 遞迴關係</h3>
        <p>
            PLONK 定義了一個累加多項式 <span class="math">\(z(X)\)</span> 來追蹤上述乘積的過程。該過程分為以下步驟：
        </p>
        <ol>
            <li><strong>挑戰值生成</strong>：Verifier 發送隨機挑戰值 <span class="math">\(\beta, \gamma\)</span>。</li>
            <li><strong>建構 Shifted Polynomials</strong>：Prover 根據 challenge 構造 <span class="math">\(f'(x) = f(x) + \beta \cdot \text{SID}(x) + \gamma\)</span> 與 <span class="math">\(g'(x) = g(x) + \beta \cdot S_{\sigma}(x) + \gamma\)</span>。</li>
            <li><strong>定義 Accumulator</strong>：Prover 計算累加多項式 <span class="math">\(z(X)\)</span>，使其滿足初始條件 <span class="math">\(z(g)=1\)</span> 以及遞迴關係：
                <span class="math">\[
                z(\omega x) = z(x) \cdot \frac{f'(x)}{g'(x)}
                \]</span>
                這確保了 <span class="math">\(z(x)\)</span> 累積了序列的比率，若最終 <span class="math">\(z(g^{n+1}) = 1\)</span>，則證明置換成立。
            </li>
            <li><strong>承諾與傳送</strong>：Prover 計算 <span class="math">\([z]_1\)</span> 並發送給 Verifier。</li>
            <li><strong>驗證檢查</strong>：Verifier 在協議後續步驟中檢查 <span class="math">\(L_1(x)(z(x)-1)=0\)</span> (初始條件) 與 <span class="math">\(z(x)f'(x) = z(\omega x)g'(x)\)</span> (遞迴關係)。</li>
        </ol>

        <h3>5.3 Extended Permutation 與 Copy Constraints</h3>
        <p>
            為了同時處理電路的三組 wire <span class="math">\(a(X), b(X), c(X)\)</span>，PLONK 將它們「串接」起來。但因為都在同一個域 <span class="math">\(H\)</span> 上定義，我們不能簡單串接，而是使用廣義位置索引（coset shifts）來區分不同 wire 的位置。
        </p>
        <p>
            具體做法是將多項式依照位置乘上二次非剩餘 (quadratic non-residues) <span class="math">\(k_1\)</span> 或 <span class="math">\(k_2\)</span>。定義 <span class="math">\(S_{ID_1}(x) = x\)</span>, <span class="math">\(S_{ID_2}(x) = k_1 x\)</span>, <span class="math">\(S_{ID_3}(x) = k_2 x\)</span>。Permutation 多項式透過 <span class="math">\(\sigma(T_C)\)</span> 連結相同 partition 內的節點，以檢驗 copy constraints。
        </p>
    </section>

    <!-- NEW SECTION: Setup -->
    <section id="setup">
        <h2>6. 通用初始設定 (Universal Setup)</h2>
        
        <p>
            PLONK 協定的第一步是生成通用的結構參考字串（SRS）。
        </p>

        <h3>6.1 MPC 儀式與 Toxic Waste</h3>
        <p>
            Setup 過程通常透過多方計算（MPC）儀式進行，稱為 "Powers of Tau"。目標是生成一系列 <span class="math">\(\tau\)</span> 的冪次加密值，同時確保沒有任何單一參與者知道 <span class="math">\(\tau\)</span> 的具體數值（稱為 <strong>Toxic Waste</strong>）。只要儀式中至少有一位參與者是誠實並銷毀了隨機數，整個 Setup 就是安全的。
        </p>
        
        <h3>6.2 Monomial Basis SRS</h3>
        <p>PLONK 使用單項式基底 (Monomial Basis) 的 SRS。為了支援添加了 Blinding 因子後的最高次數多項式，SRS 的階數 <span class="math">\(d\)</span> 需滿足 <span class="math">\(d \ge n+5\)</span>（其中 <span class="math">\(n\)</span> 為電路閘數）。其 G₁、G₂ 元素包括：</p>
        <ul>
          <li><strong>G<sub>1</sub> 元素：</strong> <span class="math">\([1]_1, [x]_1, [x^2]_1, \dots, [x^d]_1\)</span>，用於承諾多項式。</li>
          <li><strong>G<sub>2</sub> 元素：</strong> <span class="math">\([1]_2, [x]_2\)</span>（用於 Pairing 驗證）。</li>
        </ul>
        <p>其中 <span class="math">\(x\)</span> 是 MPC 儀式產生的秘密元素。</p>

        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph LR
            %% 節點樣式
            classDef actor fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef secure fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;
            classDef artifact fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;

            P1("參與者 1"):::actor
            P2("參與者 2"):::actor
            Pn("參與者 n"):::actor
            
            subgraph MPC ["MPC Ceremony"]
                Step1("隨機採樣"):::process
                Step2("更新 SRS"):::process
                Step3("隨機採樣"):::process
                StepN("最終更新"):::process
                
                P1 --> Step1 --> Step2
                P2 --> Step3 --> Step2
                Pn --> StepN
            end
            
            Toxic("Toxic Waste 銷毀"):::secure
            SRS("SRS Monomial Basis"):::artifact
            
            Step1 -.-> Toxic
            Step3 -.-> Toxic
            StepN --> SRS
            Step2 --> StepN
        </div>
    </section>

    <!-- NEW SECTION: Preprocessing -->
    <section id="preprocessing">
        <h2>7. 電路預處理 (Circuit Preprocessing)</h2>

        <p>
            在證明生成之前，電路設計者或維護者必須對算術電路進行預處理。這一步驟將電路的邏輯結構轉換為多項式形式，並生成驗證金鑰（Verification Key, VK）。
        </p>

        <h3>7.1 約束系統的算術化</h3>
        <p>
            電路被表示為一組加法閘與乘法閘。預處理階段會生成以下多項式（在 Lagrange 基底上）：
        </p>
        <ul>
            <li><strong>選擇子多項式 (Selector Polynomials)</strong>：<span class="math">\(q_L, q_R, q_O, q_M, q_C\)</span>。這些多項式在每個閘的位置 <span class="math">\(\omega^i\)</span> 上定義了該閘的類型。</li>
            <li><strong>置換多項式 (Permutation Polynomials)</strong>：<span class="math">\(S_{\sigma 1}, S_{\sigma 2}, S_{\sigma 3}\)</span>。這些多項式編碼了電路中的線路連接資訊（Copy Constraints）。</li>
        </ul>

        <h3>7.2 驗證金鑰生成</h3>
        <p>計算出的多項式經過 KZG Commit 成為群元素 <span class="math">\(\mathbb{G}_1\)</span>。</p>
        <ol>
          <li><strong>邏輯定義</strong>：將算術電路表示成閘 (Gates)、線路 (Wires)、R1CS。</li>
          <li><strong>多項式生成</strong>：計算 Selector 多項式 <span class="math">\(q_L,q_R,q_O,q_M,q_C\)</span> 與置換多項式 <span class="math">\(S_{\sigma 1},S_{\sigma 2},S_{\sigma 3}\)</span>。</li>
          <li><strong>承諾 MSM</strong>：使用 KZG PCS 對這些多項式做承諾，得到 Verification Key。</li>
        </ol>

        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            %% 樣式
            classDef artifact fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef code fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;

            subgraph Logic ["1. 邏輯定義"]
                R1CS("R1CS / Circuit"):::code
                Constraints("Gates Add Mul"):::artifact
                R1CS --> Constraints
            end

            subgraph PolyGen ["2. 多項式生成"]
                Selectors("計算 Selectors"):::process
                Perms("計算 Permutations"):::process
                
                Constraints --> Selectors
                Constraints --> Perms
            end

            subgraph Commitment ["3. 承諾 MSM"]
                SRS("SRS"):::artifact
                Commit("KZG Commit"):::process
                
                Selectors --> Commit
                Perms --> Commit
                SRS --> Commit
            end
            
            VK("Verification Key"):::artifact
            Commit --> VK
        </div>
    </section>

    <section id="proving">
        <h2>8. Prover 流程 (Proving)</h2>

        <h3>8.1 前處理回顧</h3>
        <p>
            Prover 進入證明階段前，已擁有電路的結構承諾。
        </p>

        <h3>8.2 Round 1：Wire 多項式</h3>
        <p>
            Prover 生成 wire 多項式 <span class="math">\(a(X), b(X), c(X)\)</span>。
            為了確保<strong>零知識性 (Zero-Knowledge)</strong>，這些多項式不僅僅是插值 witness，還加上了隨機 blinding 因子：
            <span class="math">\[ a(X) = (b_1 X + b_2)Z_H(X) + a_{logic}(X) \]</span>
            這些隨機項確保了即便多項式被公開部分資訊，也無法反推原始 witness。Prover 計算並發送承諾 <span class="math">\([a]_1, [b]_1, [c]_1\)</span>。
        </p>

        <h3>8.3 Round 2：Permutation Polynomial z</h3>
        <p>
            Verifier 發送挑戰 <span class="math">\(\beta, \gamma\)</span>。Prover 根據 Permutation Argument 的邏輯建構累加多項式 <span class="math">\(z(X)\)</span>。
            <span class="math">\(z(X)\)</span> 同樣包含 blinding 隨機項（使用隨機純量 $b_7, b_8, b_9$）。Prover 計算並發送 <span class="math">\([z]_1\)</span>。
        </p>

        <h3>8.4 Round 3：Quotient Polynomial t</h3>
        <p>
            Verifier 發送挑戰 <span class="math">\(\alpha\)</span>。Prover 必須證明所有約束成立。他將三種約束用 <span class="math">\(\alpha\)</span> 線性組合起來計算 <span class="math">\(t(X)\)</span>：
            <span class="math">\[ t(X) = \frac{1}{Z_H(X)} \left( \text{GateConstraints}(X) + \alpha \cdot \text{PermutationCheck}(X) + \alpha^2 \cdot \text{L1Check}(X) \right) \]</span>
            由於 <span class="math">\(t(X)\)</span> 的次數可達 <span class="math">\(3n\)</span>，必須拆解成三部分 <span class="math">\(t_{lo}, t_{mid}, t_{hi}\)</span>。
            <strong>關鍵安全性步驟：</strong>為了確保 <span class="math">\(t(X)\)</span> 不洩露資訊，我們引入隨機 blinding 因子 <span class="math">\(b_{10}, b_{11}\)</span> 對拆分後的多項式進行混淆：
            <span class="math">\[ t_{lo}(X) := t_{lo}'(X) + b_{10}X^n \]</span>
            <span class="math">\[ t_{mid}(X) := t_{mid}'(X) - b_{10} + b_{11}X^n \]</span>
            <span class="math">\[ t_{hi}(X) := t_{hi}'(X) - b_{11} \]</span>
            這種構造確保了 <span class="math">\(t_{lo} + t_{mid}X^n + t_{hi}X^{2n} = t(X)\)</span> 恆成立，同時隱藏了邊界係數。Prover 發送 <span class="math">\([t_{lo}]_1, [t_{mid}]_1, [t_{hi}]_1\)</span>。
        </p>

        <h3>8.5 Round 4：Evaluations</h3>
        <p>
            Verifier 發送挑戰點 <span class="math">\(\mathfrak{z}\)</span>。Prover 不直接打開多項式，而是只傳送它們在 <span class="math">\(\mathfrak{z}\)</span> 點的評估值（純量）：
            <span class="math">\(\bar{a}, \bar{b}, \bar{c}, \bar{S}_{\sigma 1}, \bar{S}_{\sigma 2}, \bar{z}_{\omega}\)</span>
        </p>
        <p>注意：其中 <span class="math">\(\bar{z}_{\omega} = z(\mathfrak{z}\omega)\)</span>。此外：</p>
        <ol>
          <li><span class="math">\(S_{\sigma 3}\)</span> 不需要傳送評估值（Verifier 可自行由預處理資料推導）。</li>
          <li>Permutation polynomial <span class="math">\(z(X)\)</span> 需要在 shift 點 <span class="math">\(\omega \mathfrak{z}\)</span> 進行評估，以驗證遞迴關係。</li>
          <li>商多項式 <span class="math">\(t(X)\)</span> 的貢獻透過 <span class="math">\(t_{\text{lo}}, t_{\text{mid}}, t_{\text{hi}}\)</span> 的承諾以及零多項式 <span class="math">\(Z_H\)</span> 合併到線性化多項式 <span class="math">\(r(X)\)</span> 中，故無需額外傳送 <span class="math">\(\bar t\)</span>。</li>
        </ol>

        <h3>8.6 Round 5：Linearisation 與 Opening Proof</h3>
        <p>
            Verifier 發送挑戰 <span class="math">\(v\)</span>。
            <strong>Linearization (線性化)</strong>：為了避免 Verifier 執行昂貴的高次多項式運算，Prover 建構一個線性化多項式 <span class="math">\(r(X)\)</span>。這個多項式將部分變數替換為 Round 4 的常數評估值，只保留必要的未知項。
            <span class="math">\(r(X)\)</span> 是一個組合多項式，其常數項（如 <span class="math">\(\bar{a}, \bar{b}\)</span> 等）由 Verifier 直接計算，而 <span class="math">\(r(X)\)</span> 的多項式部分包含：
        </p>
        <ul>
            <li>Selector 多項式項：<span class="math">\(q_M(X), q_L(X), q_R(X), q_O(X), q_C(X)\)</span></li>
            <li>Permutation 多項式項：<span class="math">\(z(X)\)</span> 與未被評估的 <span class="math">\(S_{\sigma 3}(X)\)</span></li>
            <li>Quotient 多項式項：<span class="math">\(t_{lo}(X), t_{mid}(X), t_{hi}(X)\)</span></li>
        </ul>
        <p>
            最後，Prover 產生兩個 Opening Proofs：
            1. <span class="math">\(W_{\mathfrak{z}}(X)\)</span>：證明 <span class="math">\(r(X)\)</span> 及其他多項式在 <span class="math">\(\mathfrak{z}\)</span> 點的值正確。
            2. <span class="math">\(W_{\mathfrak{z}\omega}(X)\)</span>：證明 <span class="math">\(z(X)\)</span> 在 <span class="math">\(\omega \mathfrak{z}\)</span> 點的值正確。
        </p>

        <!-- Detailed Proving Flowchart -->
        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            classDef round fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef challenge fill:#fbe9e7,stroke:#d84315,stroke-width:2px,stroke-dasharray: 5 5;
            classDef output fill:#fff9c4,stroke:#fbc02d,stroke-width:2px;

            Start(("開始")) --> R1Step1
            
            subgraph R1 ["Round 1"]
                R1Step1("計算 Wire Polynomials"):::round
                Blind1("Blinding (b1...b6)"):::round
                Com1("Output Commitments"):::output
                R1Step1 --> Blind1 --> Com1
            end

            Chal1("挑戰 Beta Gamma"):::challenge
            Com1 --> Chal1 --> R2Step1

            subgraph R2 ["Round 2"]
                R2Step1("計算 Acc Poly z"):::round
                Blind2("Blinding (b7...b9)"):::round
                Com2("Output z Commit"):::output
                R2Step1 --> Blind2 --> Com2
            end

            Chal2("挑戰 Alpha"):::challenge
            Com2 --> Chal2 --> R3Step1

            subgraph R3 ["Round 3"]
                R3Step1("計算 Quotient t"):::round
                Split3("拆分 t lo mid hi"):::round
                Blind3("Blinding (b10, b11)"):::round
                Com3("Output t Commits"):::output
                R3Step1 --> Split3 --> Blind3 --> Com3
            end

            Chal3("挑戰 z 點"):::challenge
            Com3 --> Chal3 --> R4Step1

            subgraph R4 ["Round 4"]
                R4Step1("計算 Evaluations"):::round
                Out4("Output Scalars"):::output
                R4Step1 --> Out4
            end

            Chal4("挑戰 v"):::challenge
            Out4 --> Chal4 --> R5Step1

            subgraph R5 ["Round 5"]
                R5Step1("Linearization"):::round
                Open5("計算 Opening Proofs"):::round
                Out5("Output Proofs"):::output
                R5Step1 --> Open5 --> Out5
            end
        </div>
    </section>

    <section id="verification">
        <h2>9. Verifier 流程 (Verification)</h2>

        <h3>9.1 驗證輸入與公開參數</h3>
        <p>
            Verifier 擁有 SRS、電路預處理承諾（Verification Key）、以及 Public Input <span class="math">\(x\)</span>。收到的 Proof 包含承諾值與評估值。
        </p>

        <h3>9.2 挑戰值重建與 Public Input</h3>
        <p>
            Verifier 根據 Transcript 重建所有隨機挑戰值。
            接著，Verifier 必須自行處理 Public Input。這對應於多項式 <span class="math">\(PI(X) = \sum_{i} x_i L_i(X)\)</span>。Verifier 計算 <span class="math">\(PI(\mathfrak{z})\)</span> 的值，這確保了 Prover 使用了正確的公開輸入來生成證明。
        </p>

        <h3>9.3 Batched Pairing 檢查</h3>
        <p>
            驗證過程的核心是確保所有多項式約束在隨機點 <span class="math">\(\mathfrak{z}\)</span> 上成立。為了提高效率，我們不會一一驗證，而是將所有檢查合併為一個大的配對等式。具體步驟如下：
        </p>
        <ol>
            <li><strong>計算線性化常數項 <span class="math">\(r_0\)</span></strong>：Verifier 利用公開的評估值（如 <span class="math">\(\bar{a}, \bar{b}, \bar{z}_\omega\)</span> 等）計算出線性化多項式 <span class="math">\(r(X)\)</span> 中的常數部分。這相當於在不完全打開 <span class="math">\(r(X)\)</span> 的情況下，預先扣除已知數值。</li>
            <li><strong>建構 <span class="math">\([D]_1\)</span></strong>：這是 Linearization Polynomial 的部分承諾。它由 <span class="math">\(r(X)\)</span> 的非常數項（保留為 Commitment 形式）與 <span class="math">\(z(X)\)</span> 的相關項組成。這一步驟將 "證明多項式恆等式" 的問題轉化為 "檢查承諾值是否正確" 的問題。</li>
            <li><strong>建構完整 Batched Commitment <span class="math">\([F]_1\)</span></strong>：Verifier 將 <span class="math">\([D]_1\)</span> 與所有 Wire Commitments (<span class="math">\([a], [b], [c]\)</span>) 及 Selector Commitments 進行線性組合（使用隨機挑戰值 <span class="math">\(v\)</span>）。這一步驟將所有不同類型的約束（Gate 約束、Permutation 約束等）壓縮到一個群元素中。</li>
            <li><strong>建構 Batched Evaluation <span class="math">\([E]_1\)</span></strong>：計算對應於 <span class="math">\([F]_1\)</span> 的預期評估值的群元素。這代表了 "如果證明正確，<span class="math">\([F]_1\)</span> 在點 <span class="math">\(\mathfrak{z}\)</span> 上應該等於的值"。</li>
        </ol>
        <p>
            最終，根據 KZG 承諾的性質，Verifier 只需要執行一次昂貴的雙線性配對（Pairing）運算，即可同時驗證上述所有步驟的正確性：
            <span class="math">\[ e([W_{\mathfrak{z}}] + u[W_{\mathfrak{z}\omega}], [x]_2) \stackrel{?}{=} e(\mathfrak{z} \cdot [W_{\mathfrak{z}}] + u \mathfrak{z}\omega \cdot [W_{\mathfrak{z}\omega}] + [F]_1 - [E]_1, [1]_2) \]</span>
            若此等式成立，則保證了電路的所有邏輯約束與連線排列皆被正確滿足。
        </p>

        <!-- Detailed Verification Flowchart -->
        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            classDef input fill:#fff9c4,stroke:#fbc02d,stroke-width:2px;
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef check fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;

            Inputs("Inputs: Proof, VK, PublicInput"):::input
            
            subgraph Reconstruct ["1. 參數重建"]
                Transcript("Transcript Hash"):::process
                Challenges("挑戰值"):::process
                Transcript --> Challenges
            end
            
            subgraph PI_Calc ["2. 公開輸入處理"]
                PI_Eval("計算 PI z"):::process
                Lagrange("計算 L1 z, Zh z"):::process
            end

            subgraph Linearization ["3. 線性化優化"]
                CalcR0("計算常數項 r0"):::process
                CalcD("建構 [D]1"):::process
                CalcF("建構 [F]1 (Batch Commit)"):::process
                CalcE("建構 [E]1 (Batch Eval)"):::process
                
                Challenges --> CalcR0
                CalcR0 --> CalcD
                CalcD --> CalcF
                CalcF --> CalcE
            end
            
            subgraph FinalCheck ["4. Pairing Check"]
                Pairing{"Pairing Check 驗證"}:::check
                Valid(["Valid Proof"])
                Invalid(["Reject"])
                
                Pairing -->|Yes| Valid
                Pairing -->|No| Invalid
            end

            Inputs --> Transcript
            Inputs --> PI_Eval
            Challenges --> PI_Eval
            PI_Eval --> CalcR0
            CalcE --> Pairing
        </div>
    </section>

    <section id="performance">
        <h2>10. 效能與實作 (Performance)</h2>

        <h3>10.1 Prover / Verifier 複雜度</h3>
        <p>
            根據論文分析與實作數據，PLONK 的效能表現如下：
        </p>
        <ul>
            <li><strong>Prover</strong>: 複雜度約為 <span class="math">9(n+a)</span> 次 <span class="math">\(\mathbb{G}_1\)</span> 指數運算。其中 <span class="math">\(n\)</span> 是乘法子群大小，<span class="math">\(a\)</span> 是 wire 數量。與 Sonic 相比，PLONK 移除了大量的昂貴計算，顯著提升速度。</li>
            <li><strong>Verifier</strong>: 複雜度固定為 <strong>2 次配對運算</strong>，這與 Groth16（3 次配對）相當甚至更優，屬於常數等級驗證。</li>
        </ul>

        <h3>10.2 與 Groth16 / Sonic / Marlin 的比較</h3>
        <table>
            <tr>
                <th>特性</th>
                <th>Groth16</th>
                <th>Sonic (Helped)</th>
                <th>PLONK</th>
                <th>Marlin</th>
            </tr>
            <tr>
                <td>SRS 類型</td>
                <td>電路專用</td>
                <td>通用、可更新</td>
                <td>通用、可更新</td>
                <td>通用、可更新</td>
            </tr>
            <tr>
                <td>Proof 大小</td>
                <td>極小 (3 group elements)</td>
                <td>中等</td>
                <td>小 (~400-600 bytes)</td>
                <td>較大</td>
            </tr>
            <tr>
                <td>Verifier 時間</td>
                <td>極快</td>
                <td>快</td>
                <td>極快</td>
                <td>快</td>
            </tr>
        </table>
        <p>
            PLONK 在通用 SRS 的前提下，達到了最接近 Groth16 的效能。雖然 Proof 大小略大於 Groth16，但在靈活性與 setup 安全性上的優勢使其成為現代 SNARK 應用的首選之一。
        </p>

        <h3>10.3 實作與 Benchmark 結果</h3>
        <p>
            在標準硬體上的基準測試顯示，對於百萬閘（<span class="math">\(2^{20}\)</span> constraints）級別的電路，PLONK 產生證明的時間可控制在 23 秒以內（參考論文圖 1 數據）。這使得它在實際應用（如 Rollup、隱私交易）中具備高度可行性。
        </p>
    </section>

    <section id="security">
        <h2>11. 安全性與擴充 (Security)</h2>

        <h3>11.1 Compiler 觀點：從 IOP 到 SNARK</h3>
        <p>
            PLONK 的安全性架構可以視為一個編譯過程。我們首先建構一個 <strong>Polynomial IOP (Interactive Oracle Proof)</strong>，確保只要 Verifier 能正確查詢多項式，Prover 就無法作弊。接著，使用 <strong>KZG Polynomial Commitment Scheme</strong> 將協議「編譯」成簡潔 SNARK。Lemma 4.7 指出：若 IOP 具備 Knowledge Soundness 且 PCS 具備 Binding 性質，則編譯後的 SNARK 也具備 Knowledge Soundness。
        </p>

        <h3>11.2 零知識性與 Blinding 技巧</h3>
        <p>
            為了達成零知識性 (Zero-Knowledge)，Prover 在關鍵多項式（wire <span class="math">\(a, b, c\)</span>, 排列 <span class="math">\(z\)</span>, 商 <span class="math">\(t\)</span>）中都加入了 <span class="math">Z_H(X)</span> 的隨機倍數。這些隨機項在 <span class="math">\(H\)</span> 上的評估值為零，不影響約束檢查，但在查詢點 <span class="math">\(\mathfrak{z}\)</span> 提供了隨機掩蓋，確保 Verifier 無法推導出 witness 資訊。
        </p>

        <h3>11.3 通用 / 可更新 SRS 的安全性</h3>
        <p>
            PLONK 使用的 Monomial SRS 儀式基於 Bowe-Gabizon-Miers 方案，支援無限次數的更新。只要任一更新者銷毀隨機數，SRS 即為安全。
        </p>

        <h3>11.4 與其他系統的關係</h3>
        <p>
            PLONK 與 Fractal 或 Marlin 的主要區別在於算術化選擇。PLONK 使用基於加法閘與乘法閘的約束系統，並透過 Permutation Argument 處理線路連接，這在特定類型的電路（如扇入為 2）中更為高效。
        </p>
    </section>

    <section id="conclusion">
        <h2>12. 結論 (Conclusion)</h2>

        <h3>12.1 工作總結</h3>
        <p>
            PLONK 成功地在「通用 SRS」、「高效 Prover」與「簡潔 Verifier」三者之間取得了極佳的平衡。透過引入 Lagrange 基底的算術化與高效的 Permutation Argument，它克服了 Sonic 的效能缺陷。
        </p>

        <h3>12.2 對 zk-SNARK 生態系的意義</h3>
        <p>
            PLONK 的出現標誌著通用 SNARK 進入實用化階段，降低了隱私應用的部署門檻，並促進了 zk-Rollup 等技術的發展。其標準化的約束系統也為工具鏈整合奠定了基礎。
        </p>

        <h3>12.3 未來可能的延伸方向</h3>
        <p>
            未來的研究包括：(1) 替換底層的多項式承諾方案（如使用 Halo 的 IPA 或 FRI）；(2) 設計自定義閘 (Custom Gates) 與查找表 (Lookup Tables)；(3) 深化與遞迴 SNARK 的整合。
        </p>

        <h3>12.4 互動式演示 (Interactive Demo)</h3>
        <p>
            為了幫助讀者更直觀地理解上述複雜的數學與協議流程，本報告特別製作了一個互動式演示頁面。您可以在該頁面中模擬 Prover 與 Verifier 的互動，並觀察各階段多項式的變化。
        </p>
        <div style="display: flex; justify-content: center; margin: 2rem 0;">
            <a href="demo.html" class="btn" style="background-color: var(--primary-color); color: white; padding: 1rem 2rem; text-decoration: none; border-radius: 4px;">前往 Live Demo</a>
        </div>
    </section>

</main>

</body>
</html>
