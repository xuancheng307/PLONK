<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlonK 協定技術報告</title>
    <!-- MathJax Configuration (Must be before loading the script) -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']]
            }
        };
    </script>
    <!-- MathJax for rendering LaTeX formulas -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Mermaid JS for Diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            mermaid.initialize({
                startOnLoad: true,
                theme: 'neutral',
                fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
                securityLevel: 'loose',
                flowchart: {
                    curve: 'basis',
                    htmlLabels: true
                }
            });
        });
    </script>
    
    <style>
        :root {
            --sidebar-width: 280px;
            --primary-color: #2c3e50;
            --link-color: #3498db;
            --bg-color: #ffffff;
            --text-color: #333333;
            --code-bg: #f8f9fa;
            --border-color: #e9ecef;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans TC", sans-serif;
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Styling */
        .sidebar {
            width: var(--sidebar-width);
            background-color: #f7f9fa;
            border-right: 1px solid var(--border-color);
            padding: 2rem 1rem;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .sidebar h1 {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: var(--primary-color);
            padding-left: 0.5rem;
        }

        .sidebar nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .sidebar nav li {
            margin-bottom: 0.5rem;
        }

        .sidebar nav a {
            text-decoration: none;
            color: #57606a;
            font-size: 0.95rem;
            display: block;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .sidebar nav a:hover, .sidebar nav a.active {
            background-color: #e1e4e8;
            color: var(--primary-color);
            font-weight: 500;
        }

        /* Main Content Styling */
        main {
            flex-grow: 1;
            padding: 2rem 4rem;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        section {
            max-width: 900px;
            margin: 0 auto 4rem auto;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 2rem;
        }

        section:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: 2rem;
            color: var(--primary-color);
            margin-top: 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.5rem;
            color: #4a5568;
            margin-top: 2rem;
        }

        h4 {
            font-size: 1.2rem;
            color: #4a5568;
            margin-top: 1.5rem;
        }

        p {
            line-height: 1.7;
            margin-bottom: 1.2rem;
            text-align: justify;
        }

        ul, ol {
            line-height: 1.7;
            margin-bottom: 1.2rem;
            padding-left: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            color: #d63384;
        }

        .math {
            font-size: 1.05em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: var(--code-bg);
            font-weight: 600;
        }

        /* Navigation Buttons */
        .section-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 1rem;
            border-top: 1px dashed var(--border-color);
        }

        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--link-color);
            text-decoration: none;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: var(--link-color);
            color: white;
            border-color: var(--link-color);
        }

        .btn.disabled {
            pointer-events: none;
            opacity: 0.5;
            background-color: #f8f9fa;
            color: #6c757d;
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
                overflow: auto;
            }
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                height: auto;
            }
            main {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>

<aside class="sidebar">
    <h1>PlonK 技術報告</h1>
    <nav>
        <ul>
            <li><a href="#abstract">0. 摘要 (Abstract)</a></li>
            <li><a href="#intro">1. 前言與動機 (Introduction)</a></li>
            <li><a href="#system-roles">2. 系統與角色模型 (System Roles)</a></li>
            <li><a href="#overview">3. 整體流程概觀 (Overview)</a></li>
            <li><a href="#math">4. 數學與建模基礎 (Math Foundation)</a></li>
            <li><a href="#permutation">5. Permutation Argument</a></li>
            <li><a href="#setup">6. 通用初始設定 (Setup)</a></li>
            <li><a href="#preprocessing">7. 電路預處理 (Preprocessing)</a></li>
            <li><a href="#proving">8. Prover 流程 (Proving)</a></li>
            <li><a href="#verification">9. Verifier 流程 (Verification)</a></li>
            <li><a href="#performance">10. 效能與實作 (Performance)</a></li>
            <li><a href="#security">11. 安全性與擴充 (Security)</a></li>
            <li><a href="#conclusion">12. 結論 (Conclusion)</a></li>
        </ul>
    </nav>
</aside>

<main>

    <section id="abstract">
        <h2>0. 摘要 (Abstract)</h2>
        <p>
            零知識簡潔非互動式知識論證（zk-SNARK）在區塊鏈隱私與擴展性應用中扮演關鍵角色。早期的 SNARK 方案（如 Groth16）依賴針對特定電路的 trusted setup，這在實際部署中產生了巨大的管理成本與安全隱憂。Sonic 協定雖然引入了通用且可更新（universal and updatable）的結構參考字串（SRS），解決了電路相依性的問題，但其證明者（Prover）的計算成本過高，導致生成證明極其緩慢，難以滿足實際應用需求。
        </p>
        <p>
            本報告分析的 PlonK 協定，旨在解決上述效能瓶頸。PlonK 的核心貢獻在於提出了一種基於拉格朗日基底（Lagrange bases）與乘法子群（multiplicative subgroup）的算術化方案，並結合了一種新穎的置換論證（permutation argument）來簡化電路中線路連接（wiring）的檢查。相較於 Sonic，PlonK 顯著降低了 Prover 所需的群指數運算次數，將複雜度從與電路大小相關的巨大常數倍數大幅縮減，使其證明生成速度提升了數倍至一個數量級。
        </p>
        <p>
            本報告將從「系統角色」與「技術流程」的角度解構 PlonK 協定。我們將詳細探討其如何透過多項式承諾方案（Polynomial Commitment Scheme）與多項式互動協議（Polynomial Interactive Oracle Proofs）來構建 SNARK。重點將放在解析其獨特的 permutation check 機制、Prover 的五輪互動流程，以及 Verifier 如何透過常數次配對運算完成高效驗證，從而實現一個通用、高效且安全的 zk-SNARK 系統。
        </p>
        <div class="section-nav">
            <a href="#" class="btn disabled">上一節</a>
            <a href="#intro" class="btn">下一節</a>
        </div>
    </section>

    <section id="intro">
        <h2>1. 前言與動機 (Introduction)</h2>
        
        <h3>1.1 背景：zk-SNARK 與通用 SRS</h3>
        <p>
            zk-SNARK 技術允許證明者向驗證者證明某個計算結果的正確性，而不洩露任何私密輸入。一個理想的「完全簡潔（fully succinct）」SNARK 應滿足四個條件：(1) SRS 生成時間短且安全，(2) Prover 計算效率高，(3) Proof 長度極短（如常數大小），(4) Verifier 驗證時間極短（如常數時間或對數時間）。早期的 Groth16 方案雖然在後兩者表現優異，但其 SRS 綁定特定電路，一旦電路邏輯修改，就需要重新進行多方計算儀式（MPC setup），這極大限制了靈活性。
        </p>

        <h3>1.2 Sonic 的限制與 PlonK 的目標</h3>
        <p>
            Sonic 協定是首個實現「通用且可更新 SRS」的實用 zk-SNARK，這意味著同一個 SRS 可以支援所有不超過特定大小的電路，且 SRS 可以隨時由新的參與者更新以增強安全性。然而，Sonic 在追求通用性的同時付出了代價：其 Prover 需要進行大量的昂貴群運算，使得證明生成變得笨重且緩慢。PlonK 的設計目標正是在保留 Sonic 通用性與可更新性優勢的同時，大幅優化 Prover 的計算複雜度，並減少 SRS 的大小，使其更接近 Groth16 的效能水準。
        </p>

        <h3>1.3 本報告的架構與閱讀方式</h3>
        <p>
            本報告將按以下結構深入剖析 PlonK：
            <ul>
                <li><strong>第 2 章</strong>：定義系統中的參與角色、信任模型與對手模型。</li>
                <li><strong>第 3–7 章</strong>：這是本報告的核心，將依序介紹整體運作流程、底層數學基礎（多項式承諾與域運算）、核心的 Permutation Argument 機制，並詳細拆解 Prover 的證明生成步驟與 Verifier 的驗證邏輯。</li>
                <li><strong>第 8–10 章</strong>：分析 PlonK 的實際效能表現、安全性論證，並總結其在隱私計算領域的應用前景與未來發展。</li>
            </ul>
        </p>
        <div class="section-nav">
            <a href="#abstract" class="btn">上一節</a>
            <a href="#system-roles" class="btn">下一節</a>
        </div>
    </section>

    <section id="system-roles">
        <h2>2. 系統與角色模型 (System Roles)</h2>

        <h3>2.1 系統概觀與信任模型</h3>
        <p>
            PlonK 建立在通用參考字串（Universal Structured Reference String, SRS）模型之上。與傳統電路專用 SRS 不同，通用的 SRS 透過多方計算（MPC）儀式生成，具有「可更新（updatable）」特性。此模型大幅降低了信任門檻，只要儀式中至少有一位參與者是誠實的，生成的 SRS 就是安全的。
        </p>

        <h3>2.2 主要角色</h3>
        <p>在理解 PlonK 時，我們區分「現實世界中的參與者」與「安全證明模型中的角色」：</p>
        
        <h4>現實世界參與者</h4>
        <ul>
            <li><strong>Setup 參與者 (Setup Participants)</strong>：負責執行 MPC 儀式，生成 monomials SRS <span class="math">\( [x^i]_1, [x^i]_2 \)</span>。</li>
            <li><strong>電路設計者 (Circuit Designer)</strong>：定義約束系統 <span class="math">\( \mathcal{C} \)</span>，產生預處理參數（選擇子與置換承諾），即 Verification Key。</li>
            <li><strong>證明者 (Prover)</strong>：持有 witness，計算證明 <span class="math">\( \pi \)</span>。</li>
            <li><strong>驗證者 (Verifier)</strong>：驗證證明 <span class="math">\( \pi \)</span>。</li>
        </ul>

        <h4>抽象模型角色 (Polynomial IOP)</h4>
        <ul>
            <li><strong>理想第三方 (Ideal Trusted Party, $\mathcal{I}$)</strong>：在抽象協議中，Prover 將多項式完整地傳送給 $\mathcal{I}$。$\mathcal{I}$ 誠實地回答 Verifier 對這些多項式在特定點的詢問（Oracle queries）。這簡化了對多項式行為的分析。</li>
            <li><strong>代數對手 (Algebraic Adversary, $\mathcal{A}$)</strong>：這是我們假設的攻擊者模型。</li>
        </ul>

        <h3>2.3 對手模型與 AGM 安全性</h3>
        <p>
            PlonK 的安全性分析基於<strong>代數群模型（Algebraic Group Model, AGM）</strong>。在此模型中，每當對手輸出一個群元素 <span class="math">\( Y \)</span>，他必須同時提供該元素如何由輸入元素 <span class="math">\( X_1, \dots, X_m \)</span> 線性組合而成的係數。
        </p>
        <p>
            <strong>Lemma 2.2 的直覺</strong>：AGM 允許我們將複雜的雙線性配對檢查（Real Pairing Check）還原為多項式恆等式檢查（Ideal Polynomial Check）。具體來說，如果一個代數對手能欺騙 Pairing Check，則相當於他在不知情的情況下解決了離散對數問題（Q-DLOG）。這確保了只要 Polynomial Protocol 是安全的（具有 Knowledge Soundness），編譯後的 SNARK 就是安全的。
        </p>
        <div class="section-nav">
            <a href="#intro" class="btn">上一節</a>
            <a href="#overview" class="btn">下一節</a>
        </div>
    </section>

    <section id="overview">
        <h2>3. 整體流程概觀 (Overview)</h2>

        <h3>3.1 協定生命週期</h3>
        <p>PlonK 的運作可以分為四個主要階段：</p>
        
        <!-- Mermaid Diagram Insertion -->
        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            %% 定義樣式
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef artifact fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;
            classDef actor fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;

            %% 1. Setup Phase
            subgraph Phase1 ["Phase 1: 通用 Setup (MPC)"]
                SetupAction("執行 MPC 儀式"):::process
                SRS("通用 SRS"):::artifact
                SetupAction --> SRS
            end

            %% 2. Preprocessing Phase
            subgraph Phase2 ["Phase 2: 電路預處理"]
                Circuit("電路邏輯 C"):::artifact
                Compile("編譯與承諾"):::process
                VK("Verification Key"):::artifact
                Circuit --> Compile
                SRS -.-> Compile
                Compile --> VK
            end

            %% 3. Proving Phase
            subgraph Phase3 ["Phase 3: 證明生成"]
                InputData("Witness + Public Input"):::artifact
                
                subgraph Rounds ["互動回合 Round 1-5"]
                    direction TB
                    R1("Round 1: Wire Polys"):::process
                    R2("Round 2: Permutation Poly"):::process
                    R3("Round 3: Quotient Poly"):::process
                    R4("Round 4: Evaluations"):::process
                    R5("Round 5: Opening Proofs"):::process
                    
                    R1 --> R2 --> R3 --> R4 --> R5
                end
                
                Proof("Proof"):::artifact
                
                SRS -.-> Rounds
                InputData --> Rounds
                R5 --> Proof
            end

            %% 4. Verification Phase
            subgraph Phase4 ["Phase 4: 驗證"]
                VerifyCheck("Pairing Check"):::process
                Result(["Accept / Reject"])
                
                SRS -.-> VerifyCheck
                VK --> VerifyCheck
                Proof --> VerifyCheck
                PI("Public Input"):::artifact --> VerifyCheck
                VerifyCheck --> Result
            end

            %% Global Data Flow Connections
            SRS -.-> Phase2
            SRS -.-> Phase3
            SRS -.-> Phase4
            
            linkStyle default stroke:#333,stroke-width:1px;
        </div>

        <ol>
            <li><strong>通用 Setup (Universal Setup)</strong>：
                <ul>
                    <li>執行一次性的 MPC 儀式。</li>
                    <li>產出全域通用的 SRS，不綁定任何特定電路。</li>
                </ul>
            </li>
            <li><strong>電路預處理 (Preprocessing)</strong>：
                <ul>
                    <li>針對特定電路 <span class="math">\( \mathcal{C} \)</span> 進行編譯。</li>
                    <li>產生 Selector 多項式 (<span class="math">\( q_L, q_R, \dots \)</span>) 與 Permutation 多項式 (<span class="math">\( S_{\sigma} \)</span>)。</li>
                    <li>計算並固定這些多項式的承諾（Commitments），成為 Verification Key。</li>
                </ul>
            </li>
            <li><strong>證明生成 (Proving) - Round 1~5</strong>：
                <ul>
                    <li>Prover 根據私密輸入 (Witness) 與公開輸入 (Public Input)，執行 5 輪互動協議。</li>
                    <li>生成包含 9 個群元素與 6 個純量值的證明 <span class="math">\( \pi \)</span>。</li>
                </ul>
            </li>
            <li><strong>驗證 (Verification)</strong>：
                <ul>
                    <li>Verifier 檢查 Proof 格式。</li>
                    <li>執行 Batched Pairing 檢查，確認所有多項式約束成立。</li>
                </ul>
            </li>
        </ol>

        <h3>3.2 資料流與訊息流</h3>
        <p>
            整個協定的資料流向如下：
            <br>
            <strong>SRS</strong> $\rightarrow$ (Setup) $\rightarrow$ <strong>Prover & Verifier</strong><br>
            <strong>Circuit Logic</strong> $\rightarrow$ (Preprocessing) $\rightarrow$ <strong>Verification Key</strong> $\rightarrow$ <strong>Verifier</strong><br>
            <strong>Witness + Public Input</strong> $\rightarrow$ (Prover Computation) $\rightarrow$ <strong>Proof $\pi$</strong> $\rightarrow$ <strong>Verifier</strong><br>
        </p>

        <h3>3.3 角色與步驟對照表</h3>
        <ul>
            <li><strong>Setup</strong>：產生 SRS <span class="math">\( \mathsf{srs} \)</span>。</li>
            <li><strong>Designer</strong>：輸出 <span class="math">\( [q_L]_1, [q_R]_1, \dots, [S_{\sigma 1}]_1, [S_{\sigma 2}]_1, [S_{\sigma 3}]_1 \)</span>。</li>
            <li><strong>Prover</strong>：
                <ul>
                    <li>Round 1: Commit wires $a, b, c$。</li>
                    <li>Round 2: Commit permutation accumulator $z$。</li>
                    <li>Round 3: Commit quotient parts $t_{lo}, t_{mid}, t_{hi}$。</li>
                    <li>Round 4: Send evaluations $\bar{a}, \bar{b}, \bar{c}, \dots$。</li>
                    <li>Round 5: Send linearization proof $W_z, W_{z\omega}$。</li>
                </ul>
            </li>
            <li><strong>Verifier</strong>：重建挑戰值，執行配對驗證。</li>
        </ul>
        <div class="section-nav">
            <a href="#system-roles" class="btn">上一節</a>
            <a href="#math" class="btn">下一節</a>
        </div>
    </section>

    <section id="math">
        <h2>4. 數學與建模基礎 (Math Foundation)</h2>

        <h3>4.1 有限域、群與配對</h3>
        <p>
            PlonK 運作在有限域 <span class="math">\( \mathbb{F} \)</span> 上。使用雙線性配對群 <span class="math">\( e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T \)</span>，其中 <span class="math">\( \mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T \)</span> 為階數為質數 <span class="math">\( p \)</span> 的群。配對函數 <span class="math">\( e \)</span> 具有雙線性性質，是驗證多項式乘法關係的基礎。
        </p>

        <h3>4.2 乘法子群與 Lagrange 基底</h3>
        <p>
            為了高效進行快速傅立葉變換（FFT）與多項式運算，PlonK 選擇一個階數為 <span class="math">\( n \)</span> 的乘法子群 <span class="math">\( H = \{1, \omega, \dots, \omega^{n-1}\} \subset \mathbb{F}^* \)</span>，其中 <span class="math">\( \omega \)</span> 是本原 <span class="math">\( n \)</span> 次單位根。這允許我們使用 Lagrange 基底 <span class="math">\( \{L_i(X)\}_{i=1}^n \)</span> 來表示多項式，其中 <span class="math">\( L_i(\omega^{j}) = \delta_{ij} \)</span>。
            這種表示法使得在 <span class="math">\( H \)</span> 上定義的約束非常稀疏且易於計算。零多項式定義為 <span class="math">\( Z_H(X) = X^n - 1 \)</span>，它在 <span class="math">\( H \)</span> 中所有點上皆為零。
        </p>

        <h3>4.3 多項式承諾 (KZG PCS)</h3>
        <p>
            PlonK 使用 Kate-Zaverucha-Goldberg (KZG) 多項式承諾方案。前文已提及，這需要通用的 SRS。
            <ul>
                <li><strong>Commit</strong>: Prover 計算 <span class="math">\( [f]_1 = f(x) \cdot G_1 \)</span>。</li>
                <li><strong>Open</strong>: Prover 證明 <span class="math">\( f(z) = y \)</span>，產生證明 <span class="math">\( \pi = \frac{f(X)-y}{X-z} \)</span> 的承諾。</li>
                <li><strong>Verify</strong>: Verifier 透過配對檢查承諾的正確性。</li>
            </ul>
            KZG 支援批次開啟（batched opening），這對減少 PlonK proof 大小至關重要。
        </p>

        <h3>4.4 Polynomial protocol 與 Ranged protocol</h3>
        <p>
            <strong>Polynomial Protocol</strong> 是一個抽象模型，Prover 將多項式發送給理想第三方 <span class="math">\( \mathcal{I} \)</span>，Verifier 查詢這些多項式在隨機點的評估值，並檢查多項式恆等式（Polynomial Identities）。
            <strong>Ranged Protocol</strong> 則處理如「對於所有 <span class="math">\( x \in H \)</span>，<span class="math">\( P(x)=0 \)</span>」這類約束。這在代數上等價於證明 <span class="math">\( P(X) \)</span> 能被 <span class="math">\( Z_H(X) \)</span> 整除，即 <span class="math">\( P(X) = Q(X) \cdot Z_H(X) \)</span>。
        </p>
        <div class="section-nav">
            <a href="#overview" class="btn">上一節</a>
            <a href="#permutation" class="btn">下一節</a>
        </div>
    </section>

    <section id="permutation">
        <h2>5. Permutation Argument</h2>

        <h3>5.1 單一多項式的 Permutation Check</h3>
        <p>
            PlonK 的核心創新在於其置換論證。基於 Bayer-Groth 的想法，若要證明兩個序列 <span class="math">\( (a_1, \dots, a_n) \)</span> 與 <span class="math">\( (b_1, \dots, b_n) \)</span> 是彼此的置換（即包含相同的元素集合），我們可以引入隨機數 <span class="math">\( \beta, \gamma \)</span>，並證明多項式乘積相等：
            <span class="math">\( \\prod_{i=1}^n (a_i + \beta \cdot i + \gamma) = \prod_{i=1}^n (b_i + \beta \cdot \sigma(i) + \gamma) \)</span>
        </p>

        <h3>5.2 Grand Product 遞迴關係</h3>
        <p>
            PlonK 定義了一個累加多項式 <span class="math">\( Z(X) \)</span> 來追蹤上述乘積的過程。我們要求 <span class="math">\( Z(X) \)</span> 在子群 <span class="math">\( H \)</span> 上滿足遞迴關係：
        </p>
        <p>令 <span class="math">Z(\omega^0)=1</span>，對於所有 <span class="math">x \in H</span> 有遞迴關係：
        <span class="math">
          Z(\omega x) = Z(x) \cdot 
            \frac{a'(x)}{b'(x)}
          = Z(x) \cdot 
            \frac{a(x)+\beta \cdot \mathrm{SID}(x) + \gamma}
                 {b(x)+\beta \cdot S_\sigma(x) + \gamma}
        </span>
        ，其中 <span class="math">a(x),b(x)</span> 為 wire 多項式，<span class="math">S_\sigma(x)</span> 為置換後的位置。</p>

        <h3>5.3 Extended Permutation 與 Copy Constraints</h3>
        <p>
            為了同時處理電路的三組 wire <span class="math">\( a(X), b(X), c(X) \)</span>，PlonK 將它們「串接」起來。但因為都在同一個域 <span class="math">\( H \)</span> 上定義，我們不能簡單串接，而是使用廣義位置索引 <span class="math">\( k_1, k_2 \)</span>（quadratic non-residues）來區分不同 wire 的位置。
            例如，左輸入的位置標記為 <span class="math">\( x \)</span>，右輸入標記為 <span class="math">\( k_1 x \)</span>，輸出標記為 <span class="math">\( k_2 x \)</span>。
            Copy constraints 透過置換 <span class="math">\( \sigma \)</span> 將這些位置連結起來。如果 <span class="math">\( Z(X) \)</span> 通過檢查，則保證了電路中所有的連線關係（例如 gate A 的輸出等於 gate B 的輸入）都是正確的。
        </p>
        <p>為了同時處理多個 wire，多項式會依照位置乘上 <span class="math">k_1</span> 或 <span class="math">k_2</span> 來區分。Permutation 多項式透過 <span class="math">\(\sigma(T_C)\)</span> 連結相同 partition 內的節點，以檢驗 copy constraints。</p>
        <div class="section-nav">
            <a href="#math" class="btn">上一節</a>
            <a href="#setup" class="btn">下一節</a>
        </div>
    </section>

    <!-- NEW SECTION: Setup -->
    <section id="setup">
        <h2>6. 通用初始設定 (Universal Setup)</h2>
        
        <p>
            PlonK 協定的第一步是生成通用的結構參考字串（SRS）。與早期的 zk-SNARK 不同，此 SRS 是「通用的（Universal）」，這意味著它可以用於任何不超過特定大小的電路，且只需生成一次。
        </p>

        <h3>6.1 MPC 儀式與 Toxic Waste</h3>
        <p>
            Setup 過程通常透過多方計算（MPC）儀式進行，稱為 "Powers of Tau"。目標是生成一系列 <span class="math">\( \tau \)</span> 的冪次加密值，同時確保沒有任何單一參與者知道 <span class="math">\( \tau \)</span> 的具體數值（稱為 Toxic Waste）。只要儀式中至少有一位參與者是誠實並銷毀了隨機數，整個 Setup 就是安全的。
        </p>
        
        <h3>6.2 Monomial Basis SRS</h3>
        <p>PlonK 使用單項式基底 (Monomial Basis) 的 SRS，其 G₁、G₂ 元素包括：</p>
        <ul>
          <li><strong>G<sub>1</sub> 元素：</strong> <span class="math">[1]_1, [r]_1, [r^2]_1, \dots, [r^d]_1</span>，用於承諾多項式。</li>
          <li><strong>G<sub>2</sub> 元素：</strong> <span class="math">[1]_2, [r]_2</span>（多數實作僅需 <span class="math">[1]_2</span> 用於 Pairing 驗證）。</li>
        </ul>
        <p>其中 <span class="math">r</span> 是 MPC 儀式產生的秘密元素，支持多項式的最高次數為 <span class="math">d</span>。</p>

        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph LR
            %% 節點樣式
            classDef actor fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef secure fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;
            classDef artifact fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;

            P1("參與者 1"):::actor
            P2("參與者 2"):::actor
            Pn("參與者 n"):::actor
            
            subgraph MPC ["MPC Ceremony"]
                Step1("隨機採樣"):::process
                Step2("更新 SRS"):::process
                Step3("隨機採樣"):::process
                StepN("最終更新"):::process
                
                P1 --> Step1 --> Step2
                P2 --> Step3 --> Step2
                Pn --> StepN
            end
            
            Toxic("Toxic Waste 銷毀"):::secure
            SRS("SRS Monomial Basis"):::artifact
            
            Step1 -.-> Toxic
            Step3 -.-> Toxic
            StepN --> SRS
            Step2 --> StepN
        </div>

        <div class="section-nav">
            <a href="#permutation" class="btn">上一節</a>
            <a href="#preprocessing" class="btn">下一節</a>
        </div>
    </section>

    <!-- NEW SECTION: Preprocessing -->
    <section id="preprocessing">
        <h2>7. 電路預處理 (Circuit Preprocessing)</h2>

        <p>
            在證明生成之前，電路設計者或維護者必須對算術電路進行預處理。這一步驟將電路的邏輯結構轉換為多項式形式，並生成驗證金鑰（Verification Key, VK）。這些資訊對 Verifier 是公開的。
        </p>

        <h3>7.1 約束系統的算術化</h3>
        <p>
            電路被表示為一組加法閘與乘法閘。預處理階段會生成以下多項式（在 Lagrange 基底上）：
            <ol>
              <li>邏輯定義：將算術電路表示成閘 (Gates)、線路 (Wires)、R1CS。</li>
              <li>多項式生成：計算 Selector 多項式 <span class="math">q_L,q_R,q_O,q_M,q_C</span> 與置換多項式 <span class="math">S_{\sigma 1},S_{\sigma 2},S_{\sigma 3}</span>。</li>
              <li>承諾 MSM：使用 KZG PCS 對這些多項式做承諾，得到 Verification Key。</li>
            </ol>
        </p>

        <h3>7.2 驗證金鑰生成</h3>
        <p>
            計算出的多項式經過 KZG Commit 成為群元素 <span class="math">\(\mathbb{G}_1\)</span>。這些承諾值構成了 VK，Verifier 將使用它們來驗證 Proof 是否對應於特定的電路邏輯。
        </p>

        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            %% 樣式
            classDef artifact fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,stroke-dasharray: 5 5;
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef code fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;

            subgraph Logic ["1. 邏輯定義"]
                R1CS("R1CS / Circuit"):::code
                Constraints("Gates: Add/Mul"):::artifact
                R1CS --> Constraints
            end

            subgraph PolyGen ["2. 多項式生成"]
                Selectors("計算 Selectors"):::process
                Perms("計算 Permutations"):::process
                
                Constraints --> Selectors
                Constraints --> Perms
            end

            subgraph Commitment ["3. 承諾 (MSM)"]
                SRS("SRS"):::artifact
                Commit("KZG Commit"):::process
                
                Selectors --> Commit
                Perms --> Commit
                SRS --> Commit
            end
            
            VK("Verification Key"):::artifact
            Commit --> VK
        </div>

        <div class="section-nav">
            <a href="#setup" class="btn">上一節</a>
            <a href="#proving" class="btn">下一節</a>
        </div>
    </section>

    <section id="proving">
        <h2>8. Prover 流程 (Proving)</h2>

        <h3>8.1 前處理回顧</h3>
        <p>
            Prover 進入證明階段前，已擁有電路的結構承諾。
        </p>

        <h3>8.2 Round 1：Wire 多項式</h3>
        <p>
            Prover 生成 wire 多項式 <span class="math">\( a(X), b(X), c(X) \)</span>。
            為了確保<strong>零知識性（Zero-Knowledge）</strong>，這些多項式不僅僅是插值 witness，還加上了隨機 blinding 因子：
            <span class="math">\( \\begin{equation*} a(X) = a_{logic}(X) + (b_1 X + b_2)Z_H(X) \\end{equation*} \)</span>
            這些隨機項確保了即便多項式被公開部分資訊，也無法反推原始 witness。Prover 計算並發送承諾 <span class="math">\( [a]_1, [b]_1, [c]_1 \)</span>。
        </p>

        <h3>8.3 Round 2：Permutation Polynomial z</h3>
        <p>
            Verifier 發送挑戰 <span class="math">\( \beta, \gamma \)</span>。Prover 根據 Permutation Argument 的邏輯建構累加多項式 <span class="math">\( z(X) \)</span>。
            <span class="math">\( z(X) \)</span> 同樣包含 blinding 隨機項。Prover 計算並發送 <span class="math">\( [z]_1 \)</span>。
        </p>

        <h3>8.4 Round 3：Quotient Polynomial t</h3>
        <p>
            Verifier 發送挑戰 <span class="math">\( \alpha \)</span>。Prover 必須證明所有約束成立。他將三種約束用 <span class="math">\( \alpha \)</span> 線性組合起來：
            <span class="math">
            t(X) = \frac{1}{Z_H(X)} \left( \text{GateConstraints}(X) + \alpha \cdot \text{PermutationCheck}(X) + \alpha^2 \cdot \text{L1Check}(X) \right)
            </span>
            由於 <span class="math">\( t(X) \)</span> 的次數可達 <span class="math">\( 3n \)</span>，超過了 SRS 的支援範圍 <span class="math">\( n \)</span>，因此必須拆解成三部分 <span class="math">\( t_{lo}, t_{mid}, t_{hi} \)</span> 分別 commit。Prover 發送 <span class="math">\( [t_{lo}]_1, [t_{mid}]_1, [t_{hi}]_1 \)</span>。
        </p>

        <h3>8.5 Round 4：Evaluations</h3>
        <p>
            Verifier 發送挑戰點 <span class="math">\( z \)</span>。Prover 不直接打開多項式，而是只傳送它們在 <span class="math">\( z \)</span> 點的評估值（純量）：
            <span class="math">\( \bar a, \bar b, \bar c, \bar S_{\sigma 1}, \bar S_{\sigma 2}, \bar z(\omega z) \)</span>
            注意：
            <ol>
              <li><span class="math">S_{\sigma 3}</span> 不需要傳送評估值（Verifier 可自行由預處理資料推導）。</li>
              <li>Permutation polynomial <span class="math">z(X)</span> 需要在 shift 點 <span class="math">\( \omega z \)</span> 進行評估，以驗證遞迴關係。</li>
              <li>商多項式 <span class="math">t(X)</span> 的貢獻透過 <span class="math">t_{\text{lo}}, t_{\text{mid}}, t_{\text{hi}}</span> 的承諾以及零多項式 <span class="math">Z_H</span> 合併到線性化多項式 <span class="math">r(X)</span> 中，故無需額外傳送 <span class="math">\( \bar t \)</span>。</li>
            </ol>
        </p>

        <h3>8.6 Round 5：Linearisation 與 Opening Proof</h3>
        <p>
            Verifier 發送挑戰 <span class="math">\( v \)</span>。
            <strong>Linearization (線性化)</strong>：為了避免 Verifier 執行昂貴的高次多項式運算，Prover 建構一個線性化多項式 <span class="math">\( r(X) \)</span>。這個多項式將部分變數替換為 Round 4 的常數評估值，只保留必要的未知項。
            線性化多項式 <span class="math">\( r(X) \)</span> 將多項式恆等式的高次結構壓縮成一次性的線性組合，使得驗證者只需在 <span class="math">X=z</span> 點與 <span class="math">X=\omega z</span> 點打開。
            最後，Prover 產生兩個 Opening Proofs：
            1. <span class="math">\( W_z(X) \)</span>：證明 <span class="math">\( r(X) \)</span> 及其他多項式在 <span class="math">\( z \)</span> 點的值正確。
            2. <span class="math">\( W_{z\omega}(X) \)</span>：證明 <span class="math">\( z(X) \)</span> 在 <span class="math">\( \omega z \)</span> 點的值正確。
        </p>

        <!-- Detailed Proving Flowchart -->
        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            classDef round fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef challenge fill:#fbe9e7,stroke:#d84315,stroke-width:2px,stroke-dasharray: 5 5;
            classDef output fill:#fff9c4,stroke:#fbc02d,stroke-width:2px;

            Start(("開始")) --> R1Step1
            
            subgraph R1 ["Round 1"]
                R1Step1("計算 Wire Polynomials"):::round
                Blind1("Blinding 處理"):::round
                Com1("Output Commitments"):::output
                R1Step1 --> Blind1 --> Com1
            end

            Chal1("挑戰 Beta Gamma"):::challenge
            Com1 --> Chal1 --> R2Step1

            subgraph R2 ["Round 2"]
                R2Step1("計算 Acc Poly z"):::round
                Blind2("Blinding"):::round
                Com2("Output z Commit"):::output
                R2Step1 --> Blind2 --> Com2
            end

            Chal2("挑戰 Alpha"):::challenge
            Com2 --> Chal2 --> R3Step1

            subgraph R3 ["Round 3"]
                R3Step1("計算 Quotient t"):::round
                Split3("拆分 t lo mid hi"):::round
                Com3("Output t Commits"):::output
                R3Step1 --> Split3 --> Com3
            end

            Chal3("挑戰 z 點"):::challenge
            Com3 --> Chal3 --> R4Step1

            subgraph R4 ["Round 4"]
                R4Step1("計算 Evaluations"):::round
                Out4("Output Scalars"):::output
                R4Step1 --> Out4
            end

            Chal4("挑戰 v"):::challenge
            Out4 --> Chal4 --> R5Step1

            subgraph R5 ["Round 5"]
                R5Step1("Linearization"):::round
                Open5("計算 Opening Proofs"):::round
                Out5("Output Proofs"):::output
                R5Step1 --> Open5 --> Out5
            end
        </div>

        <div class="section-nav">
            <a href="#preprocessing" class="btn">上一節</a>
            <a href="#verification" class="btn">下一節</a>
        </div>
    </section>

    <section id="verification">
        <h2>9. Verifier 流程 (Verification)</h2>

        <h3>9.1 驗證輸入與公開參數</h3>
        <p>
            Verifier 擁有 SRS、電路預處理承諾（Verification Key）、以及 Public Input <span class="math">\( x \)</span>。收到的 Proof 包含承諾值與評估值。
        </p>

        <h3>9.2 挑戰值重建與 Public Input</h3>
        <p>
            Verifier 根據 Transcript 重建所有隨機挑戰值。
            接著，Verifier 必須自行處理 Public Input。這對應於多項式 <span class="math">\( PI(X) = \sum_{i} x_i L_i(X) \)</span>。Verifier 計算 <span class="math">\( PI(z) \)</span> 的值，這確保了 Prover 使用了正確的公開輸入來生成證明。
        </p>

        <h3>9.3 Batched Pairing 檢查</h3>
        <p>
            Verifier 將所有需要驗證的多項式恆等式（Gate, Permutation, Evaluation correctness）透過隨機係數 <span class="math">\( v \)</span> 和 <span class="math">\( u \)</span> 壓縮成一個大的線性組合。
            最終，Verifier 將所有約束打包成單一配對等式：
            <span class="math">
              eig([W_z] + u [W_{z\omega}], [x]_2ig)
              \stackrel{?}{=}
              eig(z\,[W_z] + u\,z\omega\[W_{z\omega}] + [F]_1 - [E]_1,\,[1]_2ig),
            </span>
            其中 <span class="math">u</span> 為隨機係數、<span class="math">[F]_1</span> 是各多項式承諾按挑戰值線性組合後的結果，<span class="math">[E]_1</span> 則對應於評估值的線性組合。若等式成立，則保證所有底層約束皆被滿足。
        </p>

        <!-- Detailed Verification Flowchart -->
        <div class="mermaid" style="display: flex; justify-content: center; margin: 2rem 0;">
            graph TD
            classDef input fill:#fff9c4,stroke:#fbc02d,stroke-width:2px;
            classDef process fill:#e1f5fe,stroke:#01579b,stroke-width:2px;
            classDef check fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;

            Inputs("Inputs: Proof, VK, PublicInput"):::input
            
            subgraph Reconstruct ["1. 參數重建"]
                Transcript("Transcript Hash"):::process
                Challenges("挑戰值"):::process
                Transcript --> Challenges
            end
            
            subgraph PI_Calc ["2. 公開輸入處理"]
                PI_Eval("計算 PI z"):::process
                Lagrange("計算 L1 z, Zh z"):::process
            end

            subgraph Linearization ["3. 線性化"]
                Combine("組合 Commitment"):::process
                CombineE("組合 Evaluation"):::process
                
                Challenges --> Combine
                Challenges --> CombineE
            end
            
            subgraph FinalCheck ["4. Pairing Check"]
                Pairing("Pairing Check 驗證"):::check
                Valid(["Valid Proof"])
                Invalid(["Reject"])
                
                Pairing -->|Yes| Valid
                Pairing -->|No| Invalid
            end

            Inputs --> Transcript
            Inputs --> PI_Eval
            Challenges --> PI_Eval
            PI_Eval --> CombineE
            Combine --> Pairing
            CombineE --> Pairing
        </div>

        <div class="section-nav">
            <a href="#proving" class="btn">上一節</a>
            <a href="#performance" class="btn">下一節</a>
        </div>
    </section>

    <section id="performance">
        <h2>10. 效能與實作 (Performance)</h2>

        <h3>10.1 Prover / Verifier 複雜度</h3>
        <p>
            根據論文分析與實作數據，PlonK 的 Prover 複雜度主要由 <span class="math">\( 9(n+a) \)</span> 次 <span class="math">\( \mathbb{G}_1 \)</span> 指數運算主導，其中 <span class="math">\( n \)</span> 是乘法子群大小（近似電路閘數），<span class="math">\( a \)</span> 是 wire 數量。與 Sonic 相比，PlonK 移除了大量的昂貴計算，使得 Prover 速度顯著提升。Verifier 的複雜度固定為 2 次配對運算，這與 Groth16（3 次配對）相當甚至更優，屬於常數等級驗證。
        </p>

        <h3>10.2 與 Groth16 / Sonic / Marlin 的比較</h3>
        <table>
            <tr>
                <th>特性</th>
                <th>Groth16</th>
                <th>Sonic (Helped)</th>
                <th>PlonK</th>
                <th>Marlin</th>
            </tr>
            <tr>
                <td>SRS 類型</td>
                <td>電路專用</td>
                <td>通用、可更新</td>
                <td>通用、可更新</td>
                <td>通用、可更新</td>
            </tr>
            <tr>
                <td>Proof 大小</td>
                <td>極小 (3 group elements)</td>
                <td>中等</td>
                <td>小 (~400-600 bytes)</td>
                <td>較大</td>
            </tr>
            <tr>
                <td>Verifier 時間</td>
                <td>極快</td>
                <td>快</td>
                <td>極快</td>
                <td>快</td>
            </tr>
        </table>
        <p>
            PlonK 在通用 SRS 的前提下，達到了最接近 Groth16 的效能。雖然 Proof 大小略大於 Groth16，但在靈活性與 setup 安全性上的優勢使其成為現代 SNARK 應用的首選之一。
        </p>

        <h3>10.3 實作與 Benchmark 結果</h3>
        <p>
            在標準硬體上的基準測試顯示，對於百萬閘（<span class="math">\( 2^{20} \)</span> constraints）級別的電路，PlonK 產生證明的時間可控制在 23 秒以內（參考論文圖 1 數據）。這使得它在實際應用（如 Rollup、隱私交易）中具備高度可行性。
        </p>
        <div class="section-nav">
            <a href="#verification" class="btn">上一節</a>
            <a href="#security" class="btn">下一節</a>
        </div>
    </section>

    <section id="security">
        <h2>11. 安全性與擴充 (Security)</h2>

        <h3>11.1 Compiler 觀點：從 IOP 到 SNARK</h3>
        <p>
            PlonK 的安全性架構可以視為一個編譯過程（Compiler）。我們首先建構一個在資訊理論上安全的 <strong>Polynomial IOP (Interactive Oracle Proof)</strong>，確保只要 Verifier 能正確查詢多項式，Prover 就無法作弊。接著，我們使用 <strong>KZG Polynomial Commitment Scheme</strong> 作為密碼學後端，將這個互動協議「編譯」成一個簡潔的 SNARK。
            Lemma 4.7 指出：如果 Polynomial IOP 有 Knowledge Soundness 且 PCS 有 Binding 性質，則編譯出的 SNARK 具有 Knowledge Soundness。
        </p>

        <h3>11.2 零知識性與 Blinding 技巧</h3>
        <p>
            為了達成零知識性（Zero-Knowledge），PlonK 在 Prover 產生的每一個關鍵多項式（wire 多項式 <span class="math">\( a, b, c \)</span>, 排列多項式 <span class="math">\( z \)</span>, 商多項式 <span class="math">\( t \)</span>）中都加入了 <span class="math">\( Z_H(X) \)</span> 的隨機倍數。這些隨機項在 <span class="math">\( H \)</span> 上的評估值為零，不影響約束檢查，但在 <span class="math">\( H \)</span> 之外的查詢點（如 Verifier 的挑戰點 <span class="math">\( z \)</span>）提供了完全的隨機掩蓋，確保 Verifier 無法從評估值中推導出關於 witness 的任何資訊。
        </p>

        <h3>11.3 通用 / 可更新 SRS 的安全性</h3>
        <p>
            PlonK 使用的 Monomial SRS 儀式基於 Bowe-Gabizon-Miers 方案。該方案支援無限次數的參與者依序更新 SRS。只要其中任何一個更新者銷毀了其使用的隨機亂數（toxic waste），整個 SRS 就是安全的，這極大增強了系統在現實世界部署的信任度。
        </p>

        <h3>11.4 與其他系統的關係</h3>
        <p>
            PlonK 與 Fractal 或 Marlin 等系統的主要區別在於算術化（Arithmetization）的選擇。Marlin 使用雙變數稀疏多項式（bi-variate sparse polynomials）來處理 R1CS，而 PlonK 使用基於加法閘與乘法閘的約束系統，並透過 Permutation Argument 處理線路連接。這使得 PlonK 在處理特定類型的「扇入（fan-in）為 2」的電路時更為高效。
        </p>
        <div class="section-nav">
            <a href="#performance" class="btn">上一節</a>
            <a href="#conclusion" class="btn">下一節</a>
        </div>
    </section>

    <section id="conclusion">
        <h2>12. 結論 (Conclusion)</h2>

        <h3>12.1 工作總結</h3>
        <p>
            PlonK 成功地在「通用 SRS」、「高效 Prover」與「簡潔 Verifier」三者之間取得了極佳的平衡。透過引入 Lagrange 基底的算術化與高效的 Permutation Argument，它克服了 Sonic 證明生成緩慢的缺陷，同時保留了通用 Setup 的巨大優勢。本報告從系統角色與技術流程的角度，詳細解析了 PlonK 如何利用多項式承諾與互動協議，構建出一個現代化、高效能的 zk-SNARK 系統。
        </p>

        <h3>12.2 對 zk-SNARK 生態系的意義</h3>
        <p>
            PlonK 的出現標誌著通用 SNARK 進入實用化階段。它降低了開發者部署隱私應用的門檻（無需為每個應用重跑 Setup），並促進了如 zk-Rollup 等區塊鏈擴容技術的發展。其標準化的 Constraint System 與 Proof 結構，也為後續的工具鏈整合奠定了基礎。
        </p>

        <h3>12.3 未來可能的延伸方向</h3>
        <p>
            未來的研究與優化方向包括：(1) 替換底層的多項式承諾方案（如使用 Halo 的 IPA 或 FRI），以移除對配對友善曲線的依賴或進一步減少 setup 需求；(2) 設計自定義閘（Custom Gates）與查找表（Lookup Tables，如 Plookup），以支援更複雜的運算邏輯並減少電路大小；(3) 深化與遞迴 SNARK（Recursive SNARK）的整合，實現無限深度的證明聚合與區塊鏈狀態壓縮。
        </p>
        <div class="section-nav">
            <a href="#security" class="btn">上一節</a>
            <a href="#" class="btn disabled">下一節</a>
        </div>
    </section>

</main>

</body>
</html>
